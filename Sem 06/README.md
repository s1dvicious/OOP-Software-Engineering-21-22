# Разделна компилация. Копиращ конструктор и оператор=

## Разделна компилация.

При работа с програми с голямо проект (например с над 1000 реда) възникват редица проблеми:
- Малки промени водят до рекомпилация на цялата програма;
- Усложнява се съвместната работа върху проекта, т.е. няколко програмиста не могат да работят заедно върху един и същ проект;
- Усложнява се преизползването на отделни фрагменти от програмата, т.к. в този случай възниква рисковият копи-пейст, при който и самото навигиране из проекта става значително по-времеемко;  
  
Поради тези причини един проект бива разбит на множество изходни файлове (с разширение **.cpp**). Всеки такъв файл се компилира независимо от останалите (осъществава се разделна компилация), като не знае за тяхното съществуване. Първоначално, при компилация изходния файл бива подаден на препроцесора, който изпълнява всички директиви (започващи с #), които го променят в известен смисъл. След това изходните файлове се превръщат в обектни такива (с разширение **.obj**), като те представляват машинен код. След това идва работата на **linker**-a. Неговото предназначение е да свърже всичкия "изплют" от изходните кодове машинен код заедно в изпълним код (.exe). Той асоциира всички референции към имена (на променливи, функции, класове и т.н.) на един обектов файл към съответните им дефиниции, които могат да се намират и в други изходни файлове. Понякога се случва дефинициите да не се намират в никой от обектните файлове, като в този случай компилаторът претърсва стандартната C++ библиотека (libcp.lib), стандартната C библиотека (libc.lib), а също и всяка ръчно указана такава от програмиста. Ако такава дефиниция не бъде открита линкерът дава грешка.  

Да разиграем следните сценарии  

```c++
int main(){

f(); //call to f

return 0;
}

int f(){
return 5;
}
```
Тук **компилаторът** дава грешка - при извикване на **f** в **main** функцията той не знае какво е предназначението й - функция ли е, ако да, то какво връща, клас ли е, енъм ли е и т.н.. 

```c++
int f();

int main(){

f(); //call to f

return 0;
}
```
Тук **линкерът** дава грешка - компилаторът успешно превежда кода, но при извикване на f той не успява да намери нейната дефиниция. 

```c++
int f();

int main(){

f(); //call to f

return 0;
}

int f(){
return 20;
}
```
Тук вече работата спи, т.к. компилаторът успешно превежда кода - знае какво точно представлява f, а линкерът намира дефиницията й.  
Да разбием горното парче код на два .cpp файла. За да се компилира успешно кода е необходимо при main функцията да оставим и декларацията на f.  

![enter image description here](https://i.imgur.com/mcVGeox.jpg)  

Проблемът с този вид декларация е, че трябва да се дублира всяка декларация на една функция преди нейното използване, което е досадно. Затова се създава хедър файл .h, в който излагаме декларациите на всички функции, които искаме да изложим на външния свят. Включваме тези декларации във файл-а (в съответстващия на хедъра .cpp файл), в който са ни необходими чрез препроцесорната директива **#include** (намира това нещо и го заменя в кода), като отваряме .h файла. По този начин преди да започне същинската компилация, при всяко срещане на **#include** препроцесорът го заменя със съответстващото му парче код (хедър файл, съдържащ декларациите).  
**ODR** (_One Definition Rule_) - да разгледаме следния случай, в който при свързане, линкерът намира две различни дефиниции на функцията f  
![enter image description here](https://i.imgur.com/SE5DQIX.jpg)  
При нейно извикване в main функцията той трябва да я свърже със съответстващата й дефиниция. Обаче коя да подхване, т.к. тя се среща в два различни .obj файла, не знае. В следствие на това се чупи.  

Предназначението на header файловете е не да се компилират, а да бъдат вмъквани във файлове, които се компилират. Затова .cpp файловете ги включват в себе си. 
Един съществен проблем, който възниква при хедър файловете, че е възможно да ги включим няколко пъти. Това е напълно естествено и в общия случай не е резултат от недоглеждане. Как можем да го решим? Отговор: 
- #pragma once - директива, която казва на компилатора как да компилира даден код. Конкретно за once - казва на компилатора, че този header файл трябва да се обработи само веднъж;
- header guard-ове - първия път като минем през този хедър за пръв път да се дефинира съответното съдържание. 
Чрез #define избираме уникален идентификатор, затова му се дава името на файла (евентуално с директорията, в която се намира), например library.h именуваме като LIBRARY_H. Съответно, преди #define проверяваме - дефиниран ли е съответния индикатор, т.е. #if !defined(LIBRARY_H), което е еквивалентно на #ifndef LIBRARY_H. Съответно, ако индикаторът не е бил дефиниран - влизаме в иф-а, след което го дефинираме и изпълняваме съответния код до #endif-a. Синтаксис:
```c++
#ifndef LIBRARY_H
#define LIBRARY_H

//DO SOMETHING
	
#endif
```
съответно //DO SOMETHING ще се извърши точно веднъж 

## Копиращ конструктор и оператор =

Наред с инициализацията от предишния път, един клас може да контролира и какво се случва, когато копираме или присвояваме един обект. Тези операции се дефинират и контролират изцяло от следните две специални член-функции:  
- **Копиращ конструктор** - дефинира какво се случва, когато един обект бива инициализиран чрез друг обект (от същия тип), т.е. го създава като негово копие. Той приема като единствен аргумент обекта, който копираме като константна референция и няма **return** тип (точно както и при конструктора по подразбиране).
- Важно е, че даже и да дефинираме други конструктори (по подразбиране), то при липсата на дефиниран от нас копи конструктор компилаторът автоматично създава такъв. 

### Пример 1
```c++
class Point {
private:
	double x;
	double y;
public:

	Point() : Point(0, 0) {}
	Point(double x, double y) : x(x), y(y) {}
	Point(const Point& toCopy): Point(toCopy.x, toCopy.y){}
	void printPoint() {
		std::cout << x << " " << y;
	}
};

```

### Пример 2 (към задачата със Student)

```c++

Person(const Person& toCopy): Person(toCopy.name, toCopy.facultyNumber, toCopy.age){}   //invokes the default constructor in the initializer list
//OR without creating it as a delegating constructor
Person(const Person& toCopy){
 
                name = new char[strlen(toCopy.name) + 1]; 
		strcpy(name, toCopy.name);
		
		facultyNumber = new char[strlen(toCopy.facultyNumber) + 1];
		strcpy(facultyNumber, toCopy.facultyNumber);

		age = toCopy.age;
}

```
- **Operator =** - 
Същевременно с това как едни обекти биват инициализирани, един клас контролира и тяхното присвояване. Например
```c++
Person p1("Pesho",26);  //Invokes the default constructor of p1
Person p2;         //Default constructor
p2 = p1;           //Operator=
```
като този контрол се осигурява от специалната член функция **operator =**. Неговото предназначение е изцяло да копира съдържанието на един обект (rhs obj) в съдържанието на друг съществуващ вече такъв, какъвто е p2.  
Предефинираните оператори на един клас са специални функции, чието име е **operator**, следвани от символа, който репрезентира оператора. В нашия случай името е **operator=**. Както всички функции, те имат return type и лист от параметри. При **operator=** return type-a е референция към обект от същия тип. Причината за това ще спомена по-долу. 
В листа от параметри се представят операндите, които участват. Някои оператори, този за присвояване също, трябва да бъдат дефинирани в scope-a на класа, т.е. като член-функции. В този случай като left-hand операнда автоматично се подава **this**, т.е. обекта, върху който се извиква функцията.  
	
### Примерна имплементация на operator= върху класа Point
```c++
class Point {
private:
	double x;
	double y;
public:
	
	Point& operator=(const Point& rhs){
	
	if(this!=&rhs){
	x=rhs.x;
	y=rhs.y;
	}
	
	return *this;
	}
};
```
Работата с return type-a на този оператора e, че самата операция изобщо не зависи от типа, който връща, което е напълно логично. Точно тук може да възникне и проблем с разбирането му. Да разгледаме конструкцията ```a=b=c```. Това е същото като ```a=(b=c)```, т.к. той е дясно-асоциативен. Т.е. **b** се приравнява на **c** и след това **a** се приравнява на **b**. Записваме това като ```a.operator=(b.operator=(c))```. За да работи външното извикване на **operator=** коректно върху **a**, то return type-a на ```b.operator=(c)``` трябва да е референция към типа, който е подаден като аргумент.  

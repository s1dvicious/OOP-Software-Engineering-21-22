### Move семантики

Да разгледаме следният програмен фрагмент:
 
```c++
#include<iostream>
#include "Person.h"

Person createPerson(const char* name, int age)
{
	Person p(name, age);

	return p;
}

int main()
{
	Person p2("Petur",18);
	p2 = createPerson("Ivan", 23);
}
 ```

Тук се изпълняват следните функции на Person:

 1. Конструктор на Person (за p2)
 2. Конструктор за Person (на p).
 3. Копиращ конструктор (за *return p*)
 4. Деструктор (в края на функцията *createPerson*)
 5. Оператор = (за *p2 = create...* )   
 6. Деструктор (в края на функцията *main*)

Като при копиранията при 3 и 5 се заделя изцяло нова динамична памет, което е бавна операция. Наред с това, правим излишни копия - обектът, създаден в *createPerson* **два пъти докато се присвои** на p2. Въпросът, който възниква е: не можем ли по някакъв начин да си спестим тези копирания? Отговорът от C++11 е положителен, когато се въвеждат т.нар. **rvalue** референции, а оттам и цялата **move** семантика.  
Всеки израз в C++ е **lvalue** или **rvalue**
- **lvalue** - това са изрази, които притежават някакъв адрес в паметта, например променливи, обекти, функции, връщащи референция към някакъв тип и т.н.. 
- **rvalue** - това са изрази, които не са **lvalue**  
  
Пример
```c++
int a;
a = 4;    // = requires a (modifiable) lvalue as it's lhs, which is a
```

**lvalue**-тата могат и да не са променливи

```c++
int x;

int& getRef(){
return x;
}

int main(){

getRef()=4;  //Okay, getRef() is an lvalue - returns a reference to the global variable x

}
```
Тук getRef() връща референция към глобалната променлива **x**, която има адрес в паметта и е **lvalue**, т.е. всичко е наред.  
Колкото при **rvalue**-тата 
```c++
4 = var;        //Error
(var + 1) = 4;  //Error
```
В случая нито 4, нито (var + 1) са **lvalue**, а оттам хвърчи и грешката. 
```c++
int x;

int getRef(){
return x;
}

int main(){

getRef()=4;  //Error

}
```
Тук getRef() вече е **rvalue** - вместо да се връща референция към обекта x, се връща някакво негово локално копие.  


### rvalue референции
Важният детайл дотук е, че **rvalue** изразите се отнасят главно към обекти, които са временни, т.е. са пред изтриване. Би било хубаво да можем по някакъв начин да можем да разпознаваме точно такива обекти, т.е. да разпознаваме дали някакъв израз връща някаква временна променлива и да го пренапишем по различен начин, ако случаят е такъв. Точно тук идва и ролята на **rvalue** референциите.  
До C++11 референции към константна **rvalue** са възможни, но те не могат да изменят обекта, т.е. 
```c++
std::string getName(){
return "Pesho";
}

const std::string& name = getName(); //ok
std::string& name = getName();       //not ok
```

При C++11 се въвежда нов тип референция, а именно **rvalue** референцията, която позволява референция към **rvalue** и съответно те да бъдат променяни, но не позволява референция към **lvalue**. С други думи, **rvalue** референциите са идеалният начин за разпознаване дали една стойност заема място в паметта или не. За разлика от **lvalue** референциите, те се пишат с &&

```c++
int i = 42;
int &r = i; // ok: r refers to i
int &&rr = i; // error: cannot bind an rvalue reference to an lvalue

int &r2 = i * 42; // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue
int &&rr2 = i * 42; // ok: bind rr2 to the result of the multiplication
```

Т.к. **rvalue** референциите могат да сочат единствено към временни обекти, то обектът, който е сочен от референцията е пред изтриване. Това означава, че код, който използва **rvalue** референция свободно може да си присвои ресурсите му (или да ги открадне).  
Въпреки, че **rvalue** референции не могат да сочат към **lvalue**-та, можем cast-нем **lvalue** в съответстващата й **rvalue** референция
```c++
int x = 5;
int&& xRRef = x;   //Error: rvalue reference cannot be bound to an lvalue

int&& xRRef = std::move(x);  //Ok
```
На практика move казва на компилатора да третира **x** като **rvalue**.  
Добре, с какво ни помагат този вид референции? Ами, вече разполагаме с апарат, който еднозначно ни казва кога един израз е **lvalue** и кога е **rvalue**, т.е. можем да предефинираме една функционалност да работи по два различни начина - по един при работа с **lvalue** изрази, а по друг с **rvalue** такива.  
Например, 

```c++

void print(const string& str)
{
        cout << str;
}
 
print(string&& str)
{
        cout << str;
}

std::string lString = "Pesho";

print(lString);  //Takes an lvalue, first function
print("Ivan");   //Takes an rvalue as a parameter, hence the second function will be instantiated
```

### Move конструктор и Move assignment оператор

При всичко дотук казано и към конкретния пример в началото - как можем да си спестим копиране при return p, а също и при присвояването. В случая вместо да копираме бихме искали да преместим ресурсите от временния обект, който копираме, който е пред изтриване.  
Move конструкторът, както и копи конструкторът, приема референция към същия тип, с разликата, че това е **rvalue** референция, при това неконстантна. Идеята е следната - при създаване на обекта, крадем ресурсите на обекта, към който е референцията и го оставяме в такова състояние, че последващото му изтриване да не навреди на новосъздадения обект. При примитивните типове данни това е просто копиране. Вече при указателите, при които наша имплементация на **copy** контрола би наложила дълбоко копиране, е малко по-различно.  
Конкретно при нашия **Student** move конструкторът би изглеждал по следния начин

```c++
Student::Student(Student&& toMove): name(toMove.name), age(toMove.age) {

toMove.name = nullptr;   //Leaves toMove in a state that further destruction will do no harm!

}
```
Т.е. слагаме name да сочи към парчето памет, към което сочи toMove.name (а не заделяме наново динамична памет!), също казваме age=toMove.age. В тялото слагаме името на toMove да сочи към nullptr, т.е. при изтриване той няма да навреди по никакъв начин на обекта, в който местим ресурсите.  

### Move Assignment оператор 
Аналогично на move конструктора - конкретно при нашия пример, makeStudent("Gosho", 23) връща временна (**rvalue**) променлива, и за да си спестим излишно копиране, като в случая се извиква copy assignment оператора), дефинираме Move Assignment оператора. Аналогично на copy assignment оператора, той приема като ляв параметър обекта, върху който бива извикан, т.е. this. Десния параметър е **rvalue** референция към същия тип, или временния обект, от който искаме да преместим ресурсите. Синтаксисът тук е до голяма степен аналогична на този при copy assignment оператора

```c++
Person& operator=(Person&& toMove) noexcept{

if(this!=&toMove){

free();        //Free the resources associated with this

name = toMove.name;
age = toMove.age;

toMove.name = nullptr;  //put toMove in a state where deleting wont cause problems in further uses of this

}

return *this;
}

```

### Синтезирани move операции
Както и при копи конструктура, copy assignment оператора и деструктура, компилаторът автоматично ще синтезира move конструктор и move assignment оператор. Единствената разлика тук е, че условията, при които той прави това са различни.  
За разлика от копи операциите, за някои класове компилаторът изобщо не създава move конструктор и move assignment оператор. В частност, ако един клас дефинира свой copy конструктор, copy assignment оператор или деструктор, то move конструкторът и copy assignment операторът няма да бъдат синтезирани. Aко един клас няма move операции, то се използват copy такива (даже върху временни обекти, като точно това целим да избегнем), ако такива има разбира се.    
Компилаторът ще създаде move конструктор и move assignment оператор ако класът няма дефиниран copy control и ако всеки член може да бъде "преместен". Компилаторът може да премества вградени типове, а също и класове, които имат съответната move операция дефинирана. При примитивните типове данни местенето е просто копиране.    
За разлика от копи операциите, move операциите не могат да бъдат дефинирани като deleted функции. Въпреки това, ако експлицитно помолим компилатора да генерира move операция чрез **=default**, и компилаторът не успее да синтезира такъв, то той бива маркиран като **=deleted**. Правилата за това кога синтезираните **move** операции биват дефинирани като deleted са 
- За разлика от копи конструктора, move конструкторът бива дефиниран като deleted, ако класът има член, който дефинира copy конструктор, но не и move конструктор, или ако класът не дефинира copy контрол и компилаторът не успява да създаде move конструктор. Аналогично стоят нещата и при move assignment оператора
- Move конструкторът или move assignment операторът биват дефинирани като **deleted**, ако класът има член, чийто move конструктор или move assignment оператор е deleted или не може да бъде достъпен
- Move конструкторът бива дефиниран като deleted, ако деструкторът е deleted или не може да бъде достъпен

## TO BE CONTINUED!


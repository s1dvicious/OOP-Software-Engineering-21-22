# Статично и динамично свързване. Виртуални функции и виртуални таблици. Полиморфизъм. Абстрактни класове.
#### Статично и динамично свързване. Виртуални функции.


Да разгледаме следния фрагмент код, в който имаме два класа - **base** и **derived**, като **derived** наследява публично **base**. Наред с това, нека да допуснем, че имаме две копия на функцията **f()** - една в **base** и една в **derived**

```c++
#include <iostream>

struct base
{ 
    void f() const 
    {
	std::cout << "base::f()" << std::endl;
    }	
};

struct derived : public base
{
    void f() const 
    {
	std::cout << "derived::f()" << std::endl;
    }	
};

int main()
{       
        derived derivedObject;
 
	base* basePtr = &derivedObject;
	derived* derivedPtr = &derivedObject;
	
	basePtr -> f();                     // ??? which is called - derived::f() or base::f() ?
	derivedPtr -> f();                  //calls derived::f(), which is obvious
	
	std::cout<<"---------\n";
	
	base& baseRef = derivedObject;
	derived& derivedRef = derivedObject; 
	
	baseRef.f();                      // ??? which is called - derived::f() or base::f() ?
	derivedRef.f();                   //calls derived::f(), which is obvious
	
}
 ```
 При извикване на функцията **f()** чрез derivedPtr и derivedPtr е очевидно, че ще се извика derived::f(). Добре, обаче коя версия се извиква чрез указателя/референцията към derived? Те играят двойна роля - могат да сочат към base или derived обект, като в този ред на мисли - коя от двете функции derived::f() или base::f() ще се извика? Това, което прави компилаторът е статично (ранно) свързване, т.е. поглежда какъв е типа на това, което е отляво и понеже вижда **base***, то той допуска, че обекта, към който сочи указателя е от тип **base**. Затова директно извиква обръщение към функцията от **base**. Аналогично и при референциите. Резултатът при компилация е 
 
 ![enter image description here](https://i.imgur.com/kukiv0t.jpg)
 
 Възможно е да имаме другото поведение, т.е. по време на изпълнение не да се гледа (статично) вида на указателя и да се фиксира кода, а по време на изпълнение динамично (късно) да свърже към какъв обект сочи указателя и на тази база да извика коректната функция. Това нещо става като маркираме функцията f() с думата **virtual** при base класа. В момента, в който обявим една функция за виртуална ние казваме, че по отношение на тази операция важат други правила, а именно, че ако тя бъде извикана както по-горе през указател/референция, да не се взима автоматично типа и да се заключи коя версия на функцията е нужна, а вместо това компилатора така да генерира кода, че да познае към какъв обект сочи и да извика коректната функция. В момента, в който обявим f() за виртуална, то при всички наследници на base техните функции f() също стават виртуални. Тръгне ли една операция като виртуална, то при всички наследници е виртуална.  
 
 ```c++
#include <iostream>

struct base
{ 
    virtual void f() const 
    {
	std::cout << "base::f()" << std::endl;
    }	
};

struct derived : public base
{
    void f() const override
    {
	std::cout << "derived::f()" << std::endl;
    }	
};

int main()
{       
        derived derivedObject;
 
	base* basePtr = &derivedObject;
	derived* derivedPtr = &derivedObject;
	
	basePtr -> f();                     // calls derived::f(), dynamic binding
	derivedPtr -> f();                  //calls derived::f(), which is obvious
	
	std::cout<<"---------\n";
	
	base& baseRef = derivedObject;
	derived& derivedRef = derivedObject; 
	
	baseRef.f();                      // calls derived::f(), dynamic binding
	derivedRef.f();                   //calls derived::f(), which is obvious
	
}
 ```
 
 като в резултат на изпълнение на горния код имаме  
 
 
 ![enter image description here](https://i.imgur.com/oXb9uhN.jpg)
 
т.е. **f()** в този случай се извиква в зависимост от типа на обекта, към който сочи указателя/референцията, т.к. фунцкията е виртуална. Можем да направим и следното  

```c++
	basePtr -> f();
	basePtr->base::f();
	derivedPtr -> f();                  
	derivedPtr->base::f();
```
 В този случай това, което имаме като механизъм от виртуалните функции не работи, т.к. указваме коя конкретно функция искаме да извикаме, като очевидно свързването е статично при използването на **::** оператора.  

Добра практика е при предефиниране (overriding) на витуална функция да се използва запазената дума **override**. Причината за това е главно, че е възможно да по невнимание да объркаме например аргументите, **const/volatile** и т.н., макар и функцията да е със същото име, както и виртуалната такава, но компилаторът няма да зачете "виртуалността", а ще генерира нова функция и няма да предефинира виртуалната. Ако след дадена функция укажем **override**, то индикираме, че тази функция **трябва** да предефинира някаква виртуална функция. Например 

```c++
class base {
public:
	virtual void f()const {
		std::cout << "base::print()" << std::endl;
	}
};

class derived : public base {
public:
	void f()override {
		std::cout << "derived::print()" << std::endl;
	}
};
```
 Поради невнимателност сме изпуснали **const** при f, но в наличието на **override** се дава грешка при функцията **f()** при derived - казва, че тя не предефинира виртуална функция от базовия клас, т.к. такава не намира.  
 Друго нещо от C++11 можем да използваме е думичката **final**, която казва следното нещо - всеки клас, който наследява съответния клас не може да предифинира съответната виртуална функция 
 
 ```c++
 class base {
public:
	virtual void f()const final {
		std::cout << "base::print()" << std::endl;
	}
};

class derived : public base {
public:
	void f()const override {
		std::cout << "derived::print()" << std::endl;
	}
};
```  
и дава грешка - **не може да се предефинира final функцията base::f()**. Това може да е полезно в редица случаи, в които например в хода на веригата (на наследяване) искаме в известен момент да прекъснем това предефиниране.  
**final** може да служи и за друго нещо - ако укажем **final** след името на класа (при декларацията), то никой клас не може да го наследява.

```c++
class someClass final {};
```
## Виртуални таблици - примерна реализация 

  Да разгледаме следния фрагмент от код, в който имаме 4 класа, които участват в йерархията
  
  ```c++
class base {
public:
	virtual void f()const {
		std::cout << "base::f()" << std::endl;
	}

	virtual void g()const {
		std::cout << "base::g()" << std::endl;
	}

	void nonVirtual()const {
		std::cout << "base::nonVirtual()" << std::endl;
	}
};

class second_level : public base {
public:	
	 void f()const override {
		std::cout << "second_level::f()" << std::endl;
	}

	 void g()const override {
		std::cout << "second_level::g()" << std::endl;
	}

	 virtual void h()const {
		 std::cout << "second_level::h()" << std::endl;
	 }
};

class third_level : public second_level {
public:
	void f()const override {
		std::cout << "third_level::f()" << std::endl;
	}
};

class fourth_level : public third_level {
	void h() const override {
		std::cout << "fourth_level::h()" << std::endl;
	}
};
  ```
 и да създадем обекти от всеки един от тях
 
 ```c++
int main() {
	
	base baseObject;
	second_level secondLevelOject;
	third_level thirdLevelObject;
	fourth_level fourthLevelObject;

	base* p = nullptr;

	p = &baseObject;
	p->f();
	p->g();
	p->nonVirtual();  //static call to base::nonVirtual()
	
	std::cout << "----------" << std::endl;

	p = &secondLevelOject;
	p->f();
	p->g();

	std::cout << "----------" << std::endl;

	p = &thirdLevelObject;
	p->f();
	p->g();

	std::cout << "----------" << std::endl;

	p = &fourthLevelObject;
	p->f();
	p->g();
}
 ```
На **p** можем да му присвоим адресите на кой да е от тези обекти и за всеки един от тях бихме могли да извикаме функциите **f()** и **g()**, като компилаторът във всеки един случай трябва да може да определи коя е правилната такава, която трябва да се извика. Във връзка с горното парче код, грубо казано компилаторът прави следното - обхожда (тръгвайки от базовия, продължа класовете, които участват в йерархията и за всеки един от тях, в зависимост от това - в кой от тях коя виртуална функция се предефинира(или декларира, т.к. във всеки един момент може да се добави нова такава по веригата) и за всеки един от тях създава таблица. Таблиците държат адресите на "правилните" функции, които трябва да се извикат в последствие. 

![enter image description here](https://i.imgur.com/waaVMWb.png)

като какво прави впечатление - спазва се "индексът" на всяка една функция в хода на веригата, т.е. функцията **f()** седи все на позиция 0 в таблиците, докато **g()** - на позиция 1 и т.н. 
Какво се случва, когато създадем обектите? В момента, в който създадем обект от тип **base** той може да си има някакви променливи, но в момента, в който добавим и виртуална функция към него, скрито се добавя и допълнителен параметър - указател към съответстващата му виртуална таблица, като къде точно е разположен той - в началото, средата или края вече не е еднозначно определено. Т.е. ако имаме един **base** ptr, който където и да сочи можем да използваме следната логика: взимаме пойнтера, намираме към какво сочи. Намираме пойнтера и намираме таблицата, към която той сочи и по посочения от таблицата адрес - намираме функцията и работата спи.  

Т.е. при всяко едно от горните извиквания се процедира така  

```
p -> f(); 

// 1. p сочи към base
// 2. f е виртуална функция
// 3. на базата на p намираме обекта -> намираме таблицата -> знаем индекса в таблицата и извикваме съответната функция и в качеството на this подаваме съответния обект

```
	 

## Полиморфизъм - 4ти принцип в ООП
Едни и същи действия се реализират по различен начин в
зависимост от обектите, върху които се прилагат.

 - Действията се наричат полиморфни.
 - Реализира се чрез виртуални функции.
 - Класовете, върху които ще се прилага, трябва да имат общ родител или прародител, т.е. **да са наследници на един и същ клас**.
 - В класа се дефинира виртуален метод, съответстващ на полиморфното действие.
 - Всеки клас предефинира или не виртуалния метод.
 - Активирането става чрез указател към базов клас, на който може да се присвоят адресите на обекти на който и да е от базовите класове от йерархията

**Важно!** При полиморфна йерархия ще изтриваме обектите чрез указатели от базовия клас. За да се извикват правилните деструкори задължително **деструкторът на базовият клас** трябва е деклариран като виртуален!  
Да разгледаме случай, в който деструктора при базовия клас не е дефиниран като виртуален

```c++
class base {
public:
	virtual ~base() { std::cout << "base::~base()" << std::endl; }
	base(){ std::cout << "base::base()" << std::endl; }
};

class second_level : public base {
public:	
	~second_level() { std::cout << "second_level::~second_level()"<<std::endl; }
	second_level() { std::cout << "second_level::second_level()" << std::endl; }
};

int main() {

	base* ptr = new second_level();
	delete ptr; //invokes the destructor of base only!!! since ~base() is not virtual
}
```
при компилация получаваме  

 ![enter image description here](https://i.imgur.com/HRT3lDI.jpg)  
 
т.е. се извиква единствено деструктора на базовия клас, но не и този на second_level. Декларираме деструктора като virtual и получаваме  

 ![enter image description here](https://i.imgur.com/xCtJD1g.jpg)  
 
т.е. вече правилно се извикват съответните деструктори!  

 #### Абстрактен клас
 Понякога не можем да предоставим имплементация на една (виртуална) функция в базовия клас. Например при класа **Shape** не можем да определим как би функционирала функцията **getParameter()** или **getArea()**. Pure virtual функциите са virtual функции, които налагат имплементация при производните класове. Ако такава липсва, то и производния клас става абстрактен и съответно не може да се инстанцира! Т.е. разликата между pure virtual и virtual е, че virtual позволява override-ване на функцията, докато pure virtual го налага. 

 - Чисто виртуална функция (**pure virtual function**) - вруална функция без тяло.
 - Клас е **абстрактен**, ако в него има поне една **чисто виртуална функция**.

Тогава класът е предназначен единствено за наследяване и няма да може да създаваме обекти от него.
Така във всеки наследник ще трябва да се разпише имплементация на функцията. Ако някой наследник няма собствена имплементация, то и той става абстрактен клас.


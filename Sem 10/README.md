### Move семантики

Да разгледаме следният програмен фрагмент:
 
```c++
#include<iostream>
#include "Person.h"

Person createPerson(const char* name, int age)
{
	Person p(name, age);

	return p;
}

int main()
{
	Person p2("Petur",18);
	p2 = createPerson("Ivan", 23);
}
 ```

Тук се изпълняват следните функции на Person:

 1. Конструктор на Person (за p2)
 2. Конструктор за Person (на p).
 3. Копиращ конструктор (за *return p*)
 4. Деструктор (в края на функцията *createPerson*)
 5. Оператор = (за *p2 = create...* )   
 6. Деструктор (в края на функцията *main*)

Като при копиранията при 3 и 5 се заделя изцяло нова динамична памет, което е бавна операция. Наред с това, правим излишни копия - обектът, създаден в *createPerson* **два пъти докато се присвои** на p2. Въпросът, който възниква е: не можем ли по някакъв начин да си спестим тези копирания? Отговорът от C++11 е положителен, когато се въвеждат т.нар. **rvalue** референции, а оттам и цялата **move** семантика.  
Всеки израз в C++ е **lvalue** или **rvalue**
- **lvalue** - това са изрази, които притежават някакъв адрес в паметта, например променливи, обекти, функции, връщащи референция към някакъв тип и т.н.. 
- **rvalue** - това са изрази, които не са **lvalue**  
  
Пример
```c++
int a;
a = 4;    // = requires a (modifiable) lvalue as it's lhs, which is a
```

**lvalue**-тата могат и да не са променливи

```c++
int x;

int& getRef(){
return x;
}

int main(){

getRef()=4;  //Okay, getRef() is an lvalue - returns a reference to the global variable x

}
```
Тук getRef() връща референция към глобалната променлива **x**, която има адрес в паметта и е **lvalue**, т.е. всичко е наред.  
Колкото при **rvalue**-тата 
```c++
4 = var;        //Error
(var + 1) = 4;  //Error
```
В случая нито 4, нито (var + 1) са **lvalue**, а оттам хвърчи и грешката. 
```c++
int x;

int getRef(){
return x;
}

int main(){

getRef()=4;  //Error

}
```
Тук getRef() вече е **rvalue** - вместо да се връща референция към обекта x, се връща някакво негово локално копие.  


### rvalue референции
Важният детайл дотук е, че **rvalue** изразите се отнасят главно към обекти, които са временни, т.е. са пред изтриване. Би било хубаво да можем по някакъв начин да можем да разпознаваме точно такива обекти, т.е. да разпознаваме дали някакъв израз връща някаква временна променлива и да го пренапишем по различен начин, ако случаят е такъв. Точно тук идва и ролята на **rvalue** референциите.  
До C++11 референции към константна **rvalue** са възможни, но те не могат да изменят обекта, т.е. 
```c++
std::string getName(){
return "Pesho";
}

const std::string& name = getName(); //ok
std::string& name = getName();       //not ok
```

При C++11 се въвежда нов тип референция, а именно **rvalue** референцията, която позволява референция към **rvalue** и съответно те да бъдат променяни, но не позволява референция към **lvalue**. С други думи, **rvalue** референциите са идеалният начин за разпознаване дали една стойност заема място в паметта или не. За разлика от **lvalue** референциите, те се пишат с &&

```c++
int i = 42;
int &r = i; // ok: r refers to i
int &&rr = i; // error: cannot bind an rvalue reference to an lvalue

int &r2 = i * 42; // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue
int &&rr2 = i * 42; // ok: bind rr2 to the result of the multiplication
```

Т.к. **rvalue** референциите могат да сочат единствено към временни обекти, то обектът, който е сочен от референцията е пред изтриване. Това означава, че код, който използва **rvalue** референция свободно може да си присвои ресурсите му (или да ги открадне).  
Въпреки, че **rvalue** референции не могат да сочат към **lvalue**-та, можем cast-нем **lvalue** в съответстващата й **rvalue** референция
```c++
int x = 5;
int&& xRRef = x;   //Error: rvalue reference cannot be bound to an lvalue

int&& xRRef = std::move(x);  //Ok
```
На практика move казва на компилатора да третира **x** като **rvalue**.  
Добре, с какво ни помагат този вид референции? Ами, вече разполагаме с апарат, който еднозначно ни казва кога един израз е **lvalue** и кога е **rvalue**, т.е. можем да предефинираме една функционалност да работи по два различни начина - по един при работа с **lvalue** изрази, а по друг с **rvalue** такива.  
Например, 

```c++

void print(const string& str)
{
        cout << str;
}
 
print(string&& str)
{
        cout << str;
}

std::string lString = "Pesho";

print(lString);  //Takes an lvalue, first function
print("Ivan");   //Takes an rvalue as a parameter, hence the second function will be instantiated
```

### Move конструктор и Move assignment оператор

При всичко дотук казано и към конкретния пример в началото - как можем да си спестим копиране при return p, а също и при присвояването. В случая вместо да копираме бихме искали да преместим ресурсите от временния обект, който копираме, който е пред изтриване.  
Move конструкторът, както и копи конструкторът, приема референция към същия тип, с разликата, че това е **rvalue** референция, при това неконстантна. Идеята е следната - при създаване на обекта, крадем ресурсите на обекта, към който е референцията и го оставяме в такова състояние, че последващото му изтриване да не навреди на новосъздадения обект. При примитивните типове данни това е просто копиране. Вече при указателите, при които наша имплементация на **copy** контрола би наложила дълбоко копиране, е малко по-различно.  
Конкретно при нашия **Student** move конструкторът би изглеждал по следния начин

```c++
Student::Student(Student&& toMove): name(toMove.name), age(toMove.age) {

toMove.name = nullptr;   //Leaves toMove in a state that further destruction will do no harm!

}
```
Т.е. слагаме name да сочи към парчето памет, към което сочи toMove.name (а не заделяме наново динамична памет!), също казваме age=toMove.age. В тялото слагаме името на toMove да сочи към nullptr, т.е. при изтриване той няма да навреди по никакъв начин на обекта, в който местим ресурсите.  

### Move Assignment оператор 
Аналогично на move конструктора - конкретно при нашия пример, makeStudent("Gosho", 23) връща временна (**rvalue**) променлива, и за да си спестим излишно копиране, като в случая се извиква copy assignment оператора), дефинираме Move Assignment оператора. Аналогично на copy assignment оператора, той приема като ляв параметър обекта, върху който бива извикан, т.е. this. Десния параметър е **rvalue** референция към същия тип, или временния обект, от който искаме да преместим ресурсите. Синтаксисът тук е до голяма степен аналогична на този при copy assignment оператора

```c++
Person& operator=(Person&& toMove) noexcept{

if(this!=&toMove){

free();        //Free the resources associated with this

name = toMove.name;
age = toMove.age;

toMove.name = nullptr;  //put toMove in a state where deleting wont cause problems in further uses of this

}

return *this;
}

```

### Синтезирани move операции
Както и при копи конструктура, copy assignment оператора и деструктура, компилаторът автоматично ще синтезира move конструктор и move assignment оператор. Единствената разлика тук е, че условията, при които той прави това са различни.  
За разлика от копи операциите, за някои класове компилаторът изобщо не създава move конструктор и move assignment оператор. В частност, ако един клас дефинира свой copy конструктор, copy assignment оператор или деструктор, то move конструкторът и copy assignment операторът няма да бъдат синтезирани. Aко един клас няма move операции, то се използват copy такива (даже върху временни обекти, като точно това целим да избегнем), ако такива има разбира се.    
Компилаторът ще създаде move конструктор и move assignment оператор ако класът няма дефиниран copy control и ако всеки член може да бъде "преместен". Компилаторът може да премества вградени типове, а също и класове, които имат съответната move операция дефинирана. При примитивните типове данни местенето е просто копиране.    
За разлика от копи операциите, move операциите не могат да бъдат дефинирани като deleted функции. Въпреки това, ако експлицитно помолим компилатора да генерира move операция чрез **=default**, и компилаторът не успее да синтезира такъв, то той бива маркиран като **=deleted**. Правилата за това кога синтезираните **move** операции биват дефинирани като deleted са 
- За разлика от копи конструктора, move конструкторът бива дефиниран като deleted, ако класът има член, който дефинира copy конструктор, но не и move конструктор, или ако класът не дефинира copy контрол и компилаторът не успява да създаде move конструктор. Аналогично стоят нещата и при move assignment оператора
- Move конструкторът или move assignment операторът биват дефинирани като **deleted**, ако класът има член, чийто move конструктор или move assignment оператор е deleted или не може да бъде достъпен
- Move конструкторът бива дефиниран като deleted, ако деструкторът е deleted или не може да бъде достъпен

### Шаблони (templates)
Да разгледаме следната ситуация - реализираме функция, която сравнява две стойности и индикира дали първата е по-малка, равна или по-голяма от втората. Също, бихме искали да дефинираме тази функционалност за различни типове, да речем за **string** и **int**. Първия опит би бил да дефинираме две предефинирани функции  
```c++
//returns 0 if val1 and val2 are equal, -1 if v1 is smaller than v2, 1 if v1 is greater than v2

//compares the strings lexicographically
int compare(const string& val1, const string& val2){

if(v1 < v2) return -1;
if(v2 < v1) return 1;
return 0;

}

int compare(const int& val1, const int& val2){

if(v1 < v2) return -1;
if(v2 < v1) return 1;
return 0;

}
```

Двете функции са напълно идентични - единствената разлика помежду им е типът, който бива сравняван.  
Вместо да дефинираме по една функция за всеки тип, можем да дефинираме функцията compare като шаблонна (**function template**)  

```c++
template <typename T>
int compare(const T& val1, const T& val2){

if(v1 < v2) return -1;
if(v2 < v1) return 1;
return 0;

}
```
Като тук е от съществено значение допускането, че типът **T**, с който би работила тази шаблонна функция, има някаква наредба. Ако това не е случаят - проблем, няма как **compare** да инстанцира такава.  
При извикване на шаблонна функция, компилаторът използва аргументите, които му се подават, за да разбере с какъв тип работи. Т.е. той използва типа, който му се подава и го задава на абстрактния параметър T. Например

```c++
std::cout << compare(1, 0);        //T is int
std::cout << compare(vec1, vec2);  //T is vector<int>
```
Компилаторът ще създаде две инстанции на функцията - едната, приемаща като параметър **int**, а втората - **vector**.

В най-общи линии синтаксисът за спецификация на шаблон е 
```c++
template<typename T1, typename T2, ... , typename TN>
//function
```
Параметрите могат да се използват и като return type

```c++
template<typename T>
T sum(const T& val1, const T& val2) {
	return val1 + val2;
}

std::cout << sum(0.5, 2.5);   //T is double
std::cout << sum(23, 12);     //T is int
```

Когато компилаторът види дефиницията на шаблона, той не генерира код. Той генерира код едва когато се създаде конкретна инстанция на шаблона.  
Аналогично нещо имаме и тук - в случай, че нямаме операция **+** при конкретен даден тип за горния прототип на функцията **sum** - проблем, няма как да се инстанцира.

Пример с **swap**

```c++
template <typename T>
void swap(T& lhs, T& rhs){

T temp = lhs;   //copy
lhs = rhs;      //copy
rhs = temp;     //copy

}
```
макар че вместо да извършваме три последователно копирания, по-правилна семантика би била
```c++
template <typename T>
void swap(T& lhs, T& rhs){

T temp = std::move(lhs);   //move the contents of lhs into temp and leave lhs in a good state
lhs = std::move(rhs);      //move the contents of rhs into lhs
rhs = std::move(temp);     //move the contents of temp into rhs

}
```
Например ако искаме да swap-нем два динамична масива - вместо да заделяме динамична памет 3 пъти би било най-целесъобразно да местим по горе-указания начин.  

### Шаблонни класове
Както и при функциите, класовете могат да поддържат функционалност, която работи с различни типове. За разлика от функциите, компилаторът не може да изведе типовете, с които работи класът, затова трябва експлицитно те да се укажат при декларация на обект от шаблонен тип. 

```c++
std::vector<double> dVec;   //Creates a vector that holds double variables

std::unordered_map<short, std::pair<size_t,size_t>> myMap; //Creates an unordered map between a short and a pair of size_t's

```

или например

```c++
template<typename U, typename V>
class myPair{
U first;
V second;
};

myPair<size_t,size_t> myInstance; //creates an instance of myPair with U size_t, V size_t
```
Важен детайл е, че шаблонните класове не са класове, а единствено предоставят  
Един клас, генериран от шаблонен клас е обикновен клас. Следователно, използването на шаблон не предполага каквито и да е run-time механизми освен тези, които се използват за един еквивалентен "ръчно написан" клас. Използването на шаблони може да доведе до намаляне на генериран код, т.к. кодът за една член-функция на шаблонен клас се генерира едва когато тя бива използвана.  
Шаблонът не е нищо повече освен спецификация за това как да генерираме нещо при предоставени шаблонни аргументи;  
Членовете на един шаблонен клас се декларират и дефинират по абсолютно същия начин, по който и нешаблонните. Един шаблонен член може и да не се дефинира вътре в класа. В тозу случай, неговата дефиниция трябва да се предостави някъде другаде, както и при нешаблонните класове. Членовете на шаблонен клас са шаблони, параметризирани по параметрите на техния шаблонен клас. Когато един член се дефинира извън класа трябва експицитно да бъде дефиниран като шаблонен

```c++
template<typename U, typename V>
class myPair{
U first;
V second;

public:

U getFirst()const;
};

template<typename U, typename V>
U myPair<U,V>::getFirst() const{
return first;
}
```



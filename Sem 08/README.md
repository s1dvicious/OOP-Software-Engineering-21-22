# Предефиниране на оператори. Приятелски класове и функции.
Предефинирането на оператори ни позволява да дефинираме поведение на оператор, който се прилага върху операнда(и) от даден тип. Те са функции със специални имена: ключовата дума **operator** последвана от символа на респективния оператор (например **operator=**). Както всяка функция, те имат return type, лист от параметри и тяло.  

## Oператори
Един предефиниран оператор има толкова на брой параметра, колкото операнди. В C++ има два вида оператори:
 - Унарни (на един аргумент)  
 - Бинарни (на два аргумента)  
 
При бинарните лявата операнда се подава като първи параметър, а втората - като втори. С изключение на function call оператора **operator()**, всички предефинирани оператори приемат параметри.  
Ако един предефиниран параметър бива дефиниран като член-функция на класа, то лявата операнда бива директно асоциирана с обекта, върху който се извиква функцията, т.е. с **this**, като в този случай оператора има с един по-малко параметри.  
```
Можем да предефинираме единствено съществуващи вече оператори и не можем да създаваме нови "операторни" символи!
```  
Четирите символа (+,-,* и &) служат както за унарни, така и за бинарни оператори. Всеки от тях може да бъде предефиниран, като бройката параметри определя кой оператор влиза в употреба.  

### Операторите се характеризират с:
 -  Приоритет - при изрази с повече от един на брой оператора, определят последователността, в която ще бъдат извършени операциите; 
 -  Асоциативност - при изрази с оператори от еднакъв порядък, аналогично дефинират последователността, в която ще бъдат извършени операциите;
 -  Позиция на оператора спярмо аргумента - *префиксен*, *инфиксен* и *суфиксен*  

### Пример
```
Разглеждаме израза a~b~c~d~f. Нека бинарната операция ~ е:
- ляво асоциативна. Тогава израза приема вида (((a~b)~c)~d)~f)
- дясно асоциативна. Тогава израза приема вида (a~(b~(c~(d~f))))
```

При предефинирането на оператор **не могат** да се променят *приоритета*, *асоциативността*, броят и позицията на *аргументите* му.

### Списъка на операторите в C++ (сортирани по приоритет и асоциативност) :

| Оператор                                       | Асоциативност                   |
|------------------------------------------------|---------------------------------|
| () [] -> . ++ - -                              |         лявоасоциативен       |
|  + - ! ~ ++ - - (type)* & sizeof               |         дясноасоциативен      |
| * / %                                          | лявоасоциативен     |
|  + -        									 |      лявоасоциативен|
|    << >>      								 |      лявоасоциативен|
|  <  <=  >  >=         						 |      лявоасоциативен|
|    ==  !=       								 |      лявоасоциативен|
|      &     									 |     лявоасоциативен |
|     ^      									 |     лявоасоциативен |
|      \|     									 |      лявоасоциативен|
|       &&    									 |      лявоасоциативен|
|      \|\|     									 |      лявоасоциативен|
|      ?:    									 |      дясноасоциативен         |
|     =  +=  -=  *=  /=  %=  >>=  <<=  &=  ^=    |      дясноасоциативен         |

_В допълнение погледнете https://en.cppreference.com/w/cpp/language/operator_precedence  - тук са описани операторите в C++, не всички от които могат да бъдат предефинирани обаче!_  

При дизайн на клас: 
- Ако се извършва IO върху класа, то се дефинират shift операторите **<<** и **>>**;
- Ако класът изисква проверка за равенство, то се дефинира оператора **==**. Ако е дефиниран операторът **==**, то най-вероятно трябва да се дефинира и оператора **!=**;
- Ако класът притежава някакъв вид наредба, то се дефинира оператора **<**. При наличието на дефиниран този оператор, то трябва и да се дефинират всички останали релационни оператори;
- return type-a на един предефиниран оператор трябва да бъде съвместим с return-a на вградените (built in) оператори. Логическите и релационните оператори връщат **bool**, аритметичните - стойност от същия тип (нова, т.е. не връщаме референция), а при операторите за присвояване (```*=,  /=, +=, -=``` и т.н.) връщат референция към лявата операнда (lhs) в операцията.   

### Можем да викаме предефинирана функция и директно
Например, да допуснем, че сме предефинирали **operator+** за някакъв клас, а **test1** и **test2** са обекти от този клас. Тогава следните са еквивалентни
```c++
test1+test2;             //normal expression
//or equivalently        
operator+(test1,test2);  //equivalent expression
```
съответно извикваме оператор, дефиниран като член-функция (т.е. върху обект от съответния тип) аналогично на всяка такава
```c++
test1+=test2;
//or equivalently
test1.operator+=(test2);
```  

### Предефиниране на аритметични оператори
Обикновено ги дефинираме извън класа, т.е. не като член-функции, т.к. те не налагат промяна върху лявата операнда (в случая - **this**), а единствено връщат някаква стойност. Тези операции **НЕ** променята състоянията на коя-да е от операндите, та затова те се подават като референция към константа.  
Те обикновено генерират нова стойност, която е резултатът в следствие на използване на съоветната аритметична операция. Тази стойност се държи в локална променлива, която се връща в края на функцията.  
Когато се дефинира аритметичен оператор най-удобно е той да бъде дефиниран посредством съответстващия му съставен такъв. Причината главно е, че съставните се дефинират като член функции и всичко става много по-просто (съставните имат достъп до защитените член-данни, а също и директно могат да се използват върху локалното при дефиницията на аритметичния оператор копие, което се връща като стойност). Съставните от своя страна биват дефинирани като "композиция" на два оператора - **operator=** и **operatorX** където **X** е съответстващия на аритметичната операция символ. При нашия пример, следвайки горната логика, предефинираме аритметичния оператор **operator+** като  

```c++
complex operator+(const complex& lhs, const complex& rhs){
complex temp(lhs);        //create a local copy of lhs, calling the copy constructor of complex
temp+=rhs;                //call to the already defined compound operator +=
return temp;
}
```
където съответстващия съставен оператор е дефиниран като  
```c++
Complex& Complex::operator+=(const Complex& other)
{
	real += other.real;
	im += other.im;
	return *this;
}
 ``` 
 
Вече може да правим следното:
```c++
ina main()
{
	Complex c(1,3); //1 + 3i;
	Complex c2(10,20) // 10 + 2i;
	c += c2 // now c is 11 + 5i
	Complex c3=c1+c2; 
	//which is equivalent to
	Complex c3;
	c3.operator=(operator+(c1,c2));
}
 ```
 
### Въпрос: Кога дефинираме един оператор като член-функция?  
При предефиниране на оператори трябва да решим - да се дефинира ли като член-функция или не. В някои случаи нямаме избор, в други няма да успеем да дефинираме оператора подходящо, ако е дефиниран като член-функция.    
Следните "правила" могат да се следват като насока при решаване на този проблем:
- Присвояващия (**=**), индексния (**[]** - за достъпване на елемент, предимно при контейнери), function-call (**()**) и member access (**->** - за достъпване на елементи, при итератори и smart pointer-и) **трябва** да бъдат дефинирани като членове;
- Съставните присвояващи оператори обикновено **трябва** да бъдат дефинирани като членове. За разлика от **=** обаче, те не са задължени да бъдат такива;
- Оператори, които променят състоянието на техния обект (такива като операторите за инкрементиране, декрементиране и дереференциране) обикновено се дефинират като членове;
- Симетричните оператори - тези, които могат да преобразуват коя-да е от операндите, напр. аритметичните, релационните, побитовите - обикновено се дефинират извън класа;

При симетричните оператори обикновено разчитаме на това, че можем да я извършваме без значение от наредбта на параметрите. Например, можем да събираме **int** и **double**, като в този случай наредбата не е от значение.  
Конкретно в нашия случай - искаме да можем да умножаваме комплексно число (наредена двойка) по някакъв скалар - реално число (double). Същевременно не можем да дефинираме оператора като член-функция, но все пак искаме да имаме достъп до реалната и имагинерната част на комплексното число. Как може да се осъществи това?

## Отговор: Приятелски класове и приятелски функции
Декларират се с на запазената дума **friend** пред прототипа на функцията. Запазената дума се използва единствено веднъж - при декларация на съответната функция/клас. 
Даденият **friend**-клас/фунцкия има достъп до всички компоненти на класа. 
Т.е. всички членове на класа са public за friend-класовете/функциите приятели.
### Приятелски функции (пример)

 ```c++
class Complex{
	double real;
	double im;
public:
	friend complex operator*(const complex&, double);
	friend complex operator*(double, const complex&);
}
 ```
 И сега, така дефинирания оператор (в зависимост от наредбата на операндите) може свободно да достъпва членовете на complex (всички компоненти).  
 
  ```c++
complex operator*(const complex& obj, double scalar) {
	complex temp(obj);
	temp.real *= scalar;
	temp.im *= scalar;
	
	return temp;
}

//since the multiplication is commutative we can use the previous function in the definition of the next one

complex operator*(double scalar, const complex& obj) {
	return (obj * scalar);
}
```
### Оператори за вход/изход от/към поток
Както знаем вече, IO библиотеката използва shift операторите **>>** и **<<** за вход и изход от/към поток. Тя сама дефинира версии на тези оператори за четене и писане на вградени типове. 

### Предефиниране на operator<<
Както знаем, първия параметър на оператора за изход е референция към неконстантен **ostream** обект. Той е неконстантен, т.к. при писане в него се променя състоянието му. Референцията пък защото не можем да копираме потоци. 
Вторият параметър е референция към **const** от класа, който искаме да записваме. Референцията е с цел избягване на копиране на подавания обект. **Очевидно** той **НЕ** се дефинира като член-функция, т.к. в противен случай бихме подали като lhs обекта, който искаме да записваме, а това е грешно. Обаче е възможно (даже това най-често е случаят) да ни потрябват някои членове, които не могат да бъдат достъпвани извън класа. Затова го дефинираме като приятелска функция.  
Той връща ostream по референция.
При нашия конкретен пример
```c++
class complex{
    double real;
    double im;
public:
  friend std::ostream& operator<<(std::ostream&, const complex&);
}
//and the definition

std::ostream& operator<<(std::ostream& os, const complex& r){
return os<<r.real<<"+"<<r.im<<"i";
}
```
Хубаво е да се придържаме към минимално форматиране при предефинирането на тези оператори!  

### Предефиниране на оператор>>
Всичко тук се случва напълно аналогично, както и при предефиниране на **operator<<** - първият параметър е референция към поток за вход (istream), а втория е **неконстантна** референция към обекта, който ще записваме. Неконстантна, т.к. ще променяме неговото състояние, очевидно. Операторът връща референция към подадения поток.  
```c++
friend std::istream& operator>>(std::istream& is, complex& r){
return (is>>r.real>>r.im);
```
Тук в допълнение можем да проверяваме дали операциите за вход са били успешни, проверявайки състоянието на потока. В случай, че не са били, то слагаме обекта в default-ното му състояние (извиквайки default-ния конструктор, ако такъв съществува).  

### Предефиниране на оператори за равенство
Обикновено, класовете предефинират оператори за равенство с цел проверка еквивалентността на два обекта. Т.е., те сравняват всяка член данна на лявата операнда с всяка член данна на дясната и в случай, че са равни - връща true. Съобразно и с капсулацията се избира дали те биват дефинирани като приятели, т.к. се достъпват една по една членовете на класа, а те не биват дефинирани като член-функции.  
```c++
friend bool operator==(const complex& lhs, const complex& rhs){
return (lhs.real==rhs.real && lhs.im==rhs.im);
}
```
и съответно при дефиниран такъв оператор винаги дефинираме и **operator!=**
```c++
friend bool operator!=(const complex& lhs, const complex& rhs){
return !(lhs==rhs);
}
```
Принципите за дизайн на този оператор са следните
- Ако класът притежава операция за проверка за еквивалентност на два обекта, то тя бива дефинирана чрез **operator==**.
- Ако класът дефинира **operator==**, то той еднозначно трябва да проверява дали двата обекта са еквивалентни!
 - Той трябва да е транзитивен, т.е. ако ```a==b``` и ```b==c``` са true, то ```a==c``` е true;
 - Ако един клас дефинира **operator==**, то той трябва да дефинира и **operator!=**. Потребителите очакват и двете функционалности;
 - Имплементацията на един от двата оператори трябва да бъде включена в другия, т.е. не е необходимо да се дефинират независимо един от друг;
